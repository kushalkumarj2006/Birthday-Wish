<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<title>Happy Birthday {{FRIEND_NAME}}!</title>
<link href="https://fonts.googleapis.com/css2?family=Dancing+Script:wght@400;600;700&amp;family=Poppins:wght@300;400;500;600&amp;display=swap" rel="stylesheet"/>
<style>
      :root {
        --bg-gradient: linear-gradient(
          135deg,
          #1a0033 0%,
          #2d1b69 25%,
          #1a0033 50%,
          #2d1b69 75%,
          #1a0033 100%
        );
        --text-color: #ffffff;
        --accent-color: #ff69b4;
        --accent-secondary: #9d4edd;
        --accent-tertiary: #ffd700;
      }

      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      html,
      body {
        height: 100%;
        overflow: hidden;
      }

      body {
        font-family: "Poppins", sans-serif;
        background: var(--bg-gradient);
        color: var(--text-color);
        overflow: hidden;
        min-height: 100vh;
        position: relative;
      }

      /* Animated Background Elements */
      .bg-particles {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        pointer-events: none;
        z-index: 1;
      }

      .particle {
        position: absolute;
        border-radius: 50%;
        pointer-events: none;
        opacity: 0;
      }

      .particle-1 {
        width: 6px;
        height: 6px;
        background: var(--accent-color);
        animation: float1 8s linear infinite;
      }

      .particle-2 {
        width: 4px;
        height: 4px;
        background: var(--accent-secondary);
        animation: float2 12s linear infinite;
      }

      .particle-3 {
        width: 8px;
        height: 8px;
        background: var(--accent-tertiary);
        animation: float3 10s linear infinite;
      }

      /* Main Container */
      .container {
        position: relative;
        z-index: 10;
        height: 100vh;
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        text-align: center;
        padding: 2rem;
      }

      /* Photo Section */
      .photo-section {
        max-width: 500px;
        width: 100%;
        margin-bottom: 2rem;
        animation: fadeInUp 1.5s ease-out, photoFloat 6s ease-in-out infinite;
      }

      .photo-frame {
        position: relative;
        border-radius: 40px;
        overflow: hidden;
        box-shadow: 0 20px 40px rgba(0, 0, 0, 0.4);
        transition: transform 0.5s ease;
      }

      .photo-frame:hover {
        transform: scale(1.02);
      }

      .friend-photo {
        width: 100%;
        height: auto;
        display: block;
        border-radius: 50px;
      }

      .photo-overlay {
        position: absolute;
        bottom: 0;
        left: 0;
        right: 0;
        background: linear-gradient(transparent, rgba(0, 0, 0, 0.7));
        padding: 2rem 1rem 1rem;
        color: rgb(255, 255, 255);
        text-align: center;
      }

      .photo-overlay h2 {
        font-family: "Dancing Script", cursive;
        font-size: 2.5rem;
        margin-bottom: 0.5rem;
        text-shadow: 0 2px 4px rgba(0, 0, 0, 0.5);
        animation: textGlow 3s ease-in-out infinite alternate;
      }

      .photo-overlay p {
        font-size: 1rem;
        opacity: 0.9;
        animation: textFloat 8s ease-in-out infinite;
      }

      /* Button */
      .btn {
        background: linear-gradient(
          45deg,
          var(--accent-color),
          var(--accent-secondary)
        );
        border: none;
        color: white;
        padding: 1rem 2rem;
        border-radius: 50px;
        cursor: pointer;
        font-size: 1.1rem;
        font-weight: 600;
        box-shadow: 0 10px 30px rgba(255, 105, 180, 0.4);
        transition: all 0.4s ease;
        position: relative;
        overflow: hidden;
        margin-top: 1rem;
        font-family: "Poppins", sans-serif;
        animation: buttonFloat 4s ease-in-out infinite;
      }

      .btn::before {
        content: "";
        position: absolute;
        top: 0;
        left: -100%;
        width: 100%;
        height: 100%;
        background: linear-gradient(
          90deg,
          transparent,
          rgba(255, 255, 255, 0.4),
          transparent
        );
        transition: left 0.8s ease;
      }

      .btn:hover::before {
        left: 100%;
      }

      .btn:hover {
        transform: translateY(-5px) scale(1.05);
        box-shadow: 0 15px 40px rgba(255, 105, 180, 0.6);
        animation: buttonPulse 0.6s ease-in-out;
      }

      /* Letter Popup */
      .letter-popup {
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%) scale(0);
        background: rgba(0, 0, 0, 0.85);
        backdrop-filter: blur(15px);
        color: white;
        padding: 3rem;
        border-radius: 20px;
        max-width: 500px;
        width: 90%;
        box-shadow: 0 30px 60px rgba(0, 0, 0, 0.5);
        z-index: 100;
        border: 1px solid rgba(255, 255, 255, 0.1);
        animation: popupAppear 0.8s cubic-bezier(0.68, -0.55, 0.265, 1.55)
          forwards;
        display: none;
      }

      .letter-popup.show {
        display: block;
      }

      .letter-content {
        font-family: "Dancing Script", cursive;
        font-size: 1.8rem;
        line-height: 1.6;
        text-align: center;
        margin-bottom: 2rem;
        animation: textFloat 10s ease-in-out infinite;
      }

      .letter-content p {
        margin-bottom: 1.5rem;
        animation: textGlow 4s ease-in-out infinite alternate;
        position: relative;
      }

      .letter-content p:nth-child(2) {
        animation-delay: 0.5s;
      }

      .letter-content p:nth-child(3) {
        animation-delay: 1s;
      }

      .letter-content p:nth-child(4) {
        animation-delay: 1.5s;
      }

      .signature {
        font-family: "Dancing Script", cursive;
        font-size: 2rem;
        margin-top: 2rem;
        color: var(--accent-color);
        animation: signatureGlow 3s ease-in-out infinite alternate;
      }

      .letter-close {
        background: transparent;
        border: 2px solid var(--accent-color);
        color: var(--accent-color);
        padding: 0.5rem 1.5rem;
        border-radius: 50px;
        cursor: pointer;
        font-size: 1rem;
        transition: all 0.3s ease;
        animation: buttonFloat 3s ease-in-out infinite;
      }

      .letter-close:hover {
        background: var(--accent-color);
        color: white;
        transform: scale(1.1);
      }

      /* Floating Elements */
      .floating-item {
        position: absolute;
        opacity: 0;
        pointer-events: none;
        z-index: 3;
        font-size: 1.5rem;
      }

      .balloon {
        color: #ff6b6b;
        animation: floatBalloon 15s linear infinite;
      }

      .confetti {
        color: #ffd93d;
        animation: floatConfetti 12s linear infinite;
      }

      .gift {
        color: #6bcf7f;
        animation: floatGift 18s linear infinite;
      }

      .cake {
        color: #ff9ff3;
        animation: floatCake 14s linear infinite;
      }

      .sparkle {
        color: #ffffff;
        animation: floatSparkle 11s linear infinite;
      }

      .firework {
        color: #ff8c00;
        animation: floatFirework 13s linear infinite;
      }

      /* Fireworks Container */
      #fireworks-container {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        z-index: 5;
        pointer-events: none;
      }

      /* Animations */
      @keyframes fadeInUp {
        from {
          opacity: 0;
          transform: translateY(40px);
        }
        to {
          opacity: 1;
          transform: translateY(0);
        }
      }

      @keyframes photoFloat {
        0%,
        100% {
          transform: translateY(0px) rotateX(0deg);
        }
        25% {
          transform: translateY(-10px) rotateX(1deg);
        }
        50% {
          transform: translateY(-5px) rotateX(0deg);
        }
        75% {
          transform: translateY(-15px) rotateX(-1deg);
        }
      }

      @keyframes popupAppear {
        0% {
          transform: translate(-50%, -50%) scale(0) rotate(-180deg);
          opacity: 0;
        }
        50% {
          transform: translate(-50%, -50%) scale(1.1) rotate(0deg);
          opacity: 1;
        }
        100% {
          transform: translate(-50%, -50%) scale(1) rotate(0deg);
          opacity: 1;
        }
      }

      @keyframes textGlow {
        0% {
          text-shadow: 0 0 10px rgba(255, 105, 180, 0.5);
          filter: drop-shadow(0 0 10px rgba(255, 105, 180, 0.5));
        }
        100% {
          text-shadow: 0 0 20px rgba(255, 105, 180, 0.9),
            0 0 30px rgba(157, 78, 221, 0.7);
          filter: drop-shadow(0 0 15px rgba(255, 105, 180, 0.8));
        }
      }

      @keyframes textFloat {
        0%,
        100% {
          transform: translateY(0px) rotateZ(0deg);
        }
        25% {
          transform: translateY(-5px) rotateZ(0.5deg);
        }
        50% {
          transform: translateY(-3px) rotateZ(0deg);
        }
        75% {
          transform: translateY(-7px) rotateZ(-0.5deg);
        }
      }

      @keyframes buttonFloat {
        0%,
        100% {
          transform: translateY(0px);
        }
        50% {
          transform: translateY(-8px);
        }
      }

      @keyframes buttonPulse {
        0%,
        100% {
          transform: translateY(-5px) scale(1.05);
        }
        50% {
          transform: translateY(-8px) scale(1.08);
        }
      }

      @keyframes signatureGlow {
        0% {
          text-shadow: 0 0 5px rgba(255, 105, 180, 0.5);
          filter: drop-shadow(0 0 5px rgba(255, 105, 180, 0.5));
        }
        100% {
          text-shadow: 0 0 15px rgba(255, 105, 180, 0.9),
            0 0 25px rgba(157, 78, 221, 0.7);
          filter: drop-shadow(0 0 10px rgba(255, 105, 180, 0.8));
        }
      }

      @keyframes float1 {
        0% {
          transform: translateY(100vh) translateX(0px) rotate(0deg);
          opacity: 0;
        }
        10% {
          opacity: 1;
        }
        90% {
          opacity: 1;
        }
        100% {
          transform: translateY(-10vh) translateX(100px) rotate(360deg);
          opacity: 0;
        }
      }

      @keyframes float2 {
        0% {
          transform: translateY(100vh) translateX(0px) rotate(0deg);
          opacity: 0;
        }
        15% {
          opacity: 1;
        }
        85% {
          opacity: 1;
        }
        100% {
          transform: translateY(-10vh) translateX(-80px) rotate(-360deg);
          opacity: 0;
        }
      }

      @keyframes float3 {
        0% {
          transform: translateY(100vh) translateX(0px) rotate(0deg);
          opacity: 0;
        }
        12% {
          opacity: 1;
        }
        88% {
          opacity: 1;
        }
        100% {
          transform: translateY(-10vh) translateX(60px) rotate(180deg);
          opacity: 0;
        }
      }

      @keyframes floatBalloon {
        0% {
          transform: translateY(100vh) rotate(0deg) scale(0) translateX(0);
          opacity: 0;
        }
        10% {
          opacity: 1;
          transform: translateY(85vh) rotate(45deg) scale(0.8) translateX(20px);
        }
        30% {
          transform: translateY(60vh) rotate(120deg) scale(1.3)
            translateX(-30px);
        }
        50% {
          opacity: 1;
          transform: translateY(40vh) rotate(180deg) scale(1.5) translateX(40px);
        }
        70% {
          transform: translateY(20vh) rotate(240deg) scale(1.1)
            translateX(-20px);
        }
        90% {
          opacity: 1;
          transform: translateY(5vh) rotate(315deg) scale(0.9) translateX(10px);
        }
        100% {
          transform: translateY(-15vh) rotate(360deg) scale(0) translateX(0);
          opacity: 0;
        }
      }

      @keyframes floatConfetti {
        0% {
          transform: translateY(100vh) rotate(0deg) scale(0) translateX(0);
          opacity: 0;
        }
        15% {
          opacity: 1;
          transform: translateY(80vh) rotate(60deg) scale(0.9) translateX(25px);
        }
        35% {
          transform: translateY(55vh) rotate(140deg) scale(1.2)
            translateX(-35px);
        }
        50% {
          opacity: 1;
          transform: translateY(35vh) rotate(200deg) scale(1.4) translateX(45px);
        }
        70% {
          transform: translateY(15vh) rotate(280deg) scale(1) translateX(-25px);
        }
        85% {
          opacity: 1;
          transform: translateY(5vh) rotate(340deg) scale(0.7) translateX(15px);
        }
        100% {
          transform: translateY(-20vh) rotate(360deg) scale(0) translateX(0);
          opacity: 0;
        }
      }

      @keyframes floatGift {
        0% {
          transform: translateY(100vh) rotate(0deg) scale(0);
          opacity: 0;
        }
        18% {
          opacity: 1;
          transform: translateY(78vh) rotate(60deg) scale(0.9);
        }
        36% {
          transform: translateY(56vh) rotate(120deg) scale(1.4);
        }
        54% {
          opacity: 1;
          transform: translateY(34vh) rotate(180deg) scale(1.1);
        }
        72% {
          transform: translateY(22vh) rotate(240deg) scale(0.8);
        }
        90% {
          opacity: 1;
          transform: translateY(6vh) rotate(300deg) scale(0.6);
        }
        100% {
          transform: translateY(-12vh) rotate(360deg) scale(0);
          opacity: 0;
        }
      }

      @keyframes floatCake {
        0% {
          transform: translateY(100vh) rotate(0deg) scale(0) translateX(0);
          opacity: 0;
        }
        12% {
          opacity: 1;
          transform: translateY(82vh) rotate(40deg) scale(0.7) translateX(30px);
        }
        30% {
          transform: translateY(60vh) rotate(120deg) scale(1.3)
            translateX(-40px);
        }
        50% {
          opacity: 1;
          transform: translateY(42vh) rotate(200deg) scale(1.6) translateX(50px);
        }
        70% {
          transform: translateY(24vh) rotate(280deg) scale(1) translateX(-30px);
        }
        88% {
          opacity: 1;
          transform: translateY(8vh) rotate(340deg) scale(0.5) translateX(20px);
        }
        100% {
          transform: translateY(-18vh) rotate(360deg) scale(0) translateX(0);
          opacity: 0;
        }
      }

      @keyframes floatSparkle {
        0% {
          transform: translateY(100vh) rotate(0deg) scale(0) translateX(0);
          opacity: 0;
        }
        10% {
          opacity: 1;
          transform: translateY(85vh) rotate(30deg) scale(0.8) translateX(40px);
        }
        25% {
          transform: translateY(70vh) rotate(90deg) scale(1.1) translateX(-60px);
        }
        40% {
          transform: translateY(55vh) rotate(150deg) scale(1.3) translateX(80px);
        }
        55% {
          opacity: 1;
          transform: translateY(40vh) rotate(210deg) scale(1.2)
            translateX(-50px);
        }
        70% {
          transform: translateY(25vh) rotate(270deg) scale(0.9) translateX(30px);
        }
        85% {
          transform: translateY(10vh) rotate(330deg) scale(0.7)
            translateX(-20px);
        }
        100% {
          transform: translateY(-15vh) rotate(360deg) scale(0) translateX(0);
          opacity: 0;
        }
      }

      @keyframes floatFirework {
        0% {
          transform: translateY(100vh) rotate(0deg) scale(0) translateX(0);
          opacity: 0;
        }
        15% {
          opacity: 1;
          transform: translateY(80vh) rotate(60deg) scale(0.9) translateX(25px);
        }
        35% {
          transform: translateY(55vh) rotate(140deg) scale(1.2)
            translateX(-35px);
        }
        50% {
          opacity: 1;
          transform: translateY(35vh) rotate(200deg) scale(1.4) translateX(45px);
        }
        70% {
          transform: translateY(15vh) rotate(280deg) scale(1) translateX(-25px);
        }
        85% {
          opacity: 1;
          transform: translateY(5vh) rotate(340deg) scale(0.7) translateX(15px);
        }
        100% {
          transform: translateY(-20vh) rotate(360deg) scale(0) translateX(0);
          opacity: 0;
        }
      }

      /* Responsive Design */
      @media (max-width: 768px) {
        .container {
          padding: 1rem;
        }

        .photo-section {
          max-width: 90%;
        }

        .photo-overlay h2 {
          font-size: 2rem;
        }

        .letter-popup {
          padding: 2rem;
        }

        .letter-content {
          font-size: 1.5rem;
        }
      }
    </style>
</head>
<body>
<!-- Animated Background -->
<div class="bg-particles" id="bgParticles"></div>
<!-- Fireworks Container -->
<div id="fireworks-container"></div>
<!-- Main Content -->
<div class="container">
<div class="photo-section">
<div class="photo-frame">
<!-- Your friend's photo -->
<img alt="Your Photo" class="friend-photo" src="{{IMAGE_DATA}}"/>
<div class="photo-overlay">
<h2>Happy Birthday {{FRIEND_NAME}}!</h2>
<p>Click the button below for a special message</p>
</div>
</div>
<button class="btn" id="showLetterBtn">Open Message</button>
</div>
</div>
<!-- Letter Popup -->
<div class="letter-popup" id="letterPopup">
<div class="letter-content">
{{MESSAGE_PARAGRAPHS}}
<div class="signature">
          - {{SIGNATURE}}
        </div>
</div>
<button class="letter-close" id="closeLetterBtn">Close</button>
</div>
<script>
      // Initialize the page
      document.addEventListener("DOMContentLoaded", function () {
        initializeBackgroundParticles();
        startFloatingAnimations();

        // Start continuous fireworks
        startContinuousFireworks();

        // Set up button event listeners
        document
          .getElementById("showLetterBtn")
          .addEventListener("click", showLetter);
        document
          .getElementById("closeLetterBtn")
          .addEventListener("click", closeLetter);
      });

      // Background Particles
      function initializeBackgroundParticles() {
        const container = document.getElementById("bgParticles");

        function createParticle() {
          const particle = document.createElement("div");
          const types = ["particle-1", "particle-2", "particle-3"];
          const type = types[Math.floor(Math.random() * types.length)];

          particle.className = `particle ${type}`;
          particle.style.left = Math.random() * 100 + "%";
          particle.style.animationDelay = Math.random() * 8 + "s";

          container.appendChild(particle);

          setTimeout(() => {
            if (particle.parentNode) {
              particle.parentNode.removeChild(particle);
            }
          }, 15000);
        }

        // Create particles continuously
        setInterval(createParticle, 800);

        // Create initial particles
        for (let i = 0; i < 10; i++) {
          setTimeout(createParticle, i * 200);
        }
      }

      // Floating Animations
      function startFloatingAnimations() {
        const floatingEmojis = ["ðŸŽˆ", "ðŸŽ‰", "ðŸŽ", "ðŸŽ‚", "âœ¨", "ðŸŽ†"];
        const classes = [
          "balloon",
          "confetti",
          "gift",
          "cake",
          "sparkle",
          "firework",
        ];

        setInterval(() => {
          createFloatingElement();
        }, 1500);
      }

      function createFloatingElement() {
        const floatingEmojis = ["ðŸŽˆ", "ðŸŽ‰", "ðŸŽ", "ðŸŽ‚", "âœ¨", "ðŸŽ†"];
        const classes = [
          "balloon",
          "confetti",
          "gift",
          "cake",
          "sparkle",
          "firework",
        ];
        const index = Math.floor(Math.random() * floatingEmojis.length);

        const element = document.createElement("div");
        element.className = `floating-item ${classes[index]}`;
        element.textContent = floatingEmojis[index];
        element.style.left = Math.random() * 100 + "%";
        element.style.animationDelay = Math.random() * 2 + "s";

        document.body.appendChild(element);

        setTimeout(() => {
          if (element.parentNode) {
            element.parentNode.removeChild(element);
          }
        }, 15000);
      }

      // Show Letter Function
      function showLetter() {
        document.getElementById("letterPopup").classList.add("show");

        // Launch extra fireworks when letter is shown
        launchFireworks(10);
      }

      // Close Letter Function
      function closeLetter() {
        document.getElementById("letterPopup").classList.remove("show");
      }

      // Continuous Fireworks Function
      function startContinuousFireworks() {
        const container = document.getElementById("fireworks-container");

        // Initialize fireworks
        window.fireworks = new Fireworks(container, {
          autoresize: true,
          boundaries: {
            width: container.clientWidth,
            height: container.clientHeight,
          },
          mouse: {
            click: false,
            move: false,
            max: 1,
          },
          delay: { min: 10, max: 20 },
          traceSpeed: 8,
          acceleration: 1.02,
          particles: 80,
          explosion: 8,
          intensity: 50,
        });

        // Start the fireworks
        window.fireworks.start();
        // Launch fireworks at regular intervals
        setInterval(() => {
          if (window.fireworks && window.fireworks.isRunning) {
            launchFireworks(3);
          }
        }, 300); // 300 milliseconds

        // Also launch occasional random fireworks
        setInterval(() => {
          if (window.fireworks && window.fireworks.isRunning) {
            launchFireworks(1);
          }
        }, 150);
      }

      // Launch Fireworks Function
      function launchFireworks(count = 1) {
        if (window.fireworks && window.fireworks.isRunning) {
          window.fireworks.launchRandom(count);
        }
      }

      // Fireworks.js implementation
      class Fireworks {
        constructor(container, options = {}) {
          this.target = container;
          this.container = container;
          this.opts = new Options();
          this.createCanvas(this.target);
          this.updateOptions(options);
          this.resize = new Resize(
            this.opts,
            this.updateSize.bind(this),
            this.container
          );
          this.mouse = new Mouse(this.opts, this.canvas);
          this.raf = new RequestAnimationFrame(
            this.opts,
            this.render.bind(this)
          );

          this.traces = [];
          this.explosions = [];
          this.waitStopRaf = null;
          this.running = false;
          this.tick = 0;
          this.autoLaunchInterval = null;
          this.autoLaunchEnabled = false;

          this.updateSize();
        }

        get isRunning() {
          return this.running;
        }

        get currentOptions() {
          return this.opts;
        }

        start() {
          if (this.running) return;
          if (!this.canvas.isConnected) {
            this.createCanvas(this.target);
          }
          this.running = true;
          this.resize.mount();
          this.mouse.mount();
          this.raf.mount();
        }

        stop(dispose = false) {
          if (!this.running) return;
          this.running = false;
          this.resize.unmount();
          this.mouse.unmount();
          this.raf.unmount();
          this.clear();

          if (dispose) {
            this.canvas.remove();
          }
        }

        async waitStop(dispose) {
          if (!this.running) return;
          return new Promise((resolve) => {
            this.waitStopRaf = () => {
              if (!this.waitStopRaf) return;
              requestAnimationFrame(this.waitStopRaf);
              if (!this.traces.length && !this.explosions.length) {
                this.waitStopRaf = null;
                this.stop(dispose);
                resolve();
              }
            };
            this.waitStopRaf();
          });
        }

        pause() {
          this.running = !this.running;
          if (this.running) {
            this.raf.mount();
          } else {
            this.raf.unmount();
          }
        }

        clear() {
          if (!this.ctx) return;
          this.traces = [];
          this.explosions = [];
          this.ctx.clearRect(0, 0, this.width, this.height);
        }

        launch(count = 1) {
          for (let i = 0; i < count; i++) {
            this.createTrace();
          }
          if (!this.waitStopRaf) {
            this.start();
            this.waitStop();
          }
        }

        // New method to launch fireworks in random directions
        launchRandom(count = 3) {
          for (let i = 0; i < count; i++) {
            this.createRandomTrace();
          }
          if (!this.waitStopRaf) {
            this.start();
            this.waitStop();
          }
        }

        updateOptions(options) {
          this.opts.update(options);
        }

        updateSize({
          width = this.container.clientWidth,
          height = this.container.clientHeight,
        } = {}) {
          this.width = width;
          this.height = height;
          this.canvas.width = width;
          this.canvas.height = height;
          this.updateBoundaries({
            ...this.opts.boundaries,
            width,
            height,
          });
        }

        updateBoundaries(boundaries) {
          this.updateOptions({ boundaries });
        }

        createCanvas(el) {
          if (el instanceof HTMLCanvasElement) {
            if (!el.isConnected) {
              document.body.append(el);
            }
            this.canvas = el;
          } else {
            this.canvas = document.createElement("canvas");
            this.container.append(this.canvas);
          }
          this.ctx = this.canvas.getContext("2d");
          this.updateSize();
        }

        render() {
          if (!this.ctx || !this.running) return;
          const { opacity, lineStyle, lineWidth } = this.opts;

          this.ctx.globalCompositeOperation = "destination-out";
          this.ctx.fillStyle = `rgba(0, 0, 0, ${opacity})`;
          this.ctx.fillRect(0, 0, this.width, this.height);

          this.ctx.globalCompositeOperation = "lighter";
          this.ctx.lineCap = lineStyle;
          this.ctx.lineJoin = "round";
          this.ctx.lineWidth = randomFloat(
            lineWidth.trace.min,
            lineWidth.trace.max
          );

          this.initTrace();
          this.drawTrace();
          this.drawExplosion();
        }

        createTrace() {
          const {
            hue,
            rocketsPoint,
            boundaries,
            traceLength,
            traceSpeed,
            acceleration,
            mouse,
          } = this.opts;

          this.traces.push(
            new Trace({
              x:
                (this.width * randomInt(rocketsPoint.min, rocketsPoint.max)) /
                100,
              y: this.height,
              dx:
                (this.mouse.x && mouse.move) || this.mouse.active
                  ? this.mouse.x
                  : randomInt(
                      boundaries.x,
                      boundaries.width - boundaries.x * 2
                    ),
              dy:
                (this.mouse.y && mouse.move) || this.mouse.active
                  ? this.mouse.y
                  : randomInt(boundaries.y, boundaries.height * 0.5),
              ctx: this.ctx,
              hue: randomInt(hue.min, hue.max),
              speed: traceSpeed,
              acceleration,
              traceLength: floor(traceLength),
            })
          );
        }

        // New method to create traces with random directions
        createRandomTrace() {
          const { hue, traceLength, traceSpeed, acceleration } = this.opts;

          // Random starting point along the bottom
          const startX = randomInt(0, this.width);

          // Random target point in the upper portion of the screen
          const targetX = randomInt(0, this.width);
          const targetY = randomInt(0, this.height * 0.7);

          this.traces.push(
            new Trace({
              x: startX,
              y: this.height,
              dx: targetX,
              dy: targetY,
              ctx: this.ctx,
              hue: randomInt(hue.min, hue.max),
              speed: traceSpeed,
              acceleration,
              traceLength: floor(traceLength),
            })
          );
        }

        initTrace() {
          if (this.waitStopRaf) return;
          const { delay, mouse } = this.opts;

          if (
            this.tick > randomInt(delay.min, delay.max) ||
            (this.mouse.active && mouse.max > this.traces.length)
          ) {
            this.createTrace();
            this.tick = 0;
          }
        }

        drawTrace() {
          let traceLength = this.traces.length;
          while (traceLength--) {
            this.traces[traceLength].draw();
            this.traces[traceLength].update((x, y, hue) => {
              this.initExplosion(x, y, hue);
              this.traces.splice(traceLength, 1);
            });
          }
        }

        initExplosion(x, y, hue) {
          const {
            particles,
            flickering,
            lineWidth,
            explosion,
            brightness,
            friction,
            gravity,
            decay,
          } = this.opts;
          let particlesLength = floor(particles);

          while (particlesLength--) {
            this.explosions.push(
              new Explosion({
                x,
                y,
                ctx: this.ctx,
                hue,
                friction,
                gravity,
                flickering: randomInt(0, 100) <= flickering,
                lineWidth: randomFloat(
                  lineWidth.explosion.min,
                  lineWidth.explosion.max
                ),
                explosionLength: floor(explosion),
                brightness,
                decay,
              })
            );
          }
        }

        drawExplosion() {
          let length = this.explosions.length;
          while (length--) {
            this.explosions[length].draw();
            this.explosions[length].update(() => {
              this.explosions.splice(length, 1);
            });
          }
        }
      }

      // Helper functions
      function floor(num) {
        return Math.abs(Math.floor(num));
      }

      function randomFloat(min, max) {
        return Math.random() * (max - min) + min;
      }

      function randomInt(min, max) {
        return Math.floor(randomFloat(min, max + 1));
      }

      function getDistance(x, y, dx, dy) {
        const pow = Math.pow;
        return Math.sqrt(pow(x - dx, 2) + pow(y - dy, 2));
      }

      function hsla(hue, lightness, alpha = 1) {
        if (hue > 360 || hue < 0) {
          throw new Error(`Expected hue 0-360 range, got \`${hue}\``);
        }
        if (lightness > 100 || lightness < 0) {
          throw new Error(
            `Expected lightness 0-100 range, got \`${lightness}\``
          );
        }
        if (alpha > 1 || alpha < 0) {
          throw new Error(`Expected alpha 0-1 range, got \`${alpha}\``);
        }
        return `hsla(${hue}, 100%, ${lightness}%, ${alpha})`;
      }

      function debounce(fn, ms) {
        let timeoutId;
        return (...args) => {
          if (timeoutId) {
            clearTimeout(timeoutId);
          }
          timeoutId = setTimeout(() => fn(...args), ms);
        };
      }

      // Options class
      class Options {
        constructor() {
          this.autoresize = true;
          this.lineStyle = "round";
          this.flickering = 50;
          this.traceLength = 3;
          this.traceSpeed = 10;
          this.intensity = 30;
          this.explosion = 5;
          this.gravity = 1.5;
          this.opacity = 0.5;
          this.particles = 50;
          this.friction = 0.95;
          this.acceleration = 1.05;
          this.hue = { min: 0, max: 360 };
          this.rocketsPoint = { min: 50, max: 50 };
          this.lineWidth = {
            explosion: { min: 1, max: 3 },
            trace: { min: 1, max: 2 },
          };
          this.mouse = { click: false, move: false, max: 1 };
          this.delay = { min: 30, max: 60 };
          this.brightness = { min: 50, max: 80 };
          this.decay = { min: 0.015, max: 0.03 };
          this.boundaries = {
            debug: false,
            height: 0,
            width: 0,
            x: 50,
            y: 50,
          };
        }

        update(options) {
          Object.assign(this, this.deepMerge(this, options));
        }

        deepMerge(target, source) {
          const result = { ...target };

          for (const key in source) {
            if (source.hasOwnProperty(key)) {
              if (
                typeof source[key] === "object" &&
                source[key] !== null &&
                typeof result[key] === "object" &&
                result[key] !== null
              ) {
                result[key] = this.deepMerge(result[key], source[key]);
              } else {
                result[key] = source[key];
              }
            }
          }

          return result;
        }
      }

      // Trace class
      class Trace {
        constructor({
          x,
          y,
          dx,
          dy,
          ctx,
          hue,
          speed,
          traceLength,
          acceleration,
        }) {
          this.x = x;
          this.y = y;
          this.sx = x;
          this.sy = y;
          this.dx = dx;
          this.dy = dy;
          this.ctx = ctx;
          this.hue = hue;
          this.speed = speed;
          this.traceLength = traceLength;
          this.acceleration = acceleration;
          this.totalDistance = getDistance(x, y, dx, dy);
          this.angle = Math.atan2(dy - y, dx - x);
          this.brightness = randomInt(50, 70);
          this.coordinates = [];
          this.currentDistance = 0;

          while (this.traceLength--) {
            this.coordinates.push([x, y]);
          }
        }

        update(callback) {
          this.coordinates.pop();
          this.coordinates.unshift([this.x, this.y]);

          this.speed *= this.acceleration;
          const vx = Math.cos(this.angle) * this.speed;
          const vy = Math.sin(this.angle) * this.speed;

          this.currentDistance = getDistance(
            this.sx,
            this.sy,
            this.x + vx,
            this.y + vy
          );

          if (this.currentDistance >= this.totalDistance) {
            callback(this.dx, this.dy, this.hue);
          } else {
            this.x += vx;
            this.y += vy;
          }
        }

        draw() {
          const lastIndex = this.coordinates.length - 1;
          this.ctx.beginPath();
          this.ctx.moveTo(
            this.coordinates[lastIndex][0],
            this.coordinates[lastIndex][1]
          );
          this.ctx.lineTo(this.x, this.y);
          this.ctx.strokeStyle = hsla(this.hue, this.brightness);
          this.ctx.stroke();
        }
      }

      // Explosion class
      class Explosion {
        constructor({
          x,
          y,
          ctx,
          hue,
          decay,
          gravity,
          friction,
          brightness,
          flickering,
          lineWidth,
          explosionLength,
        }) {
          this.x = x;
          this.y = y;
          this.ctx = ctx;
          this.hue = hue;
          this.gravity = gravity;
          this.friction = friction;
          this.flickering = flickering;
          this.lineWidth = lineWidth;
          this.explosionLength = explosionLength;
          this.angle = randomFloat(0, Math.PI * 2);
          this.speed = randomInt(1, 10);
          this.brightness = randomInt(brightness.min, brightness.max);
          this.decay = randomFloat(decay.min, decay.max);
          this.alpha = 1;
          this.coordinates = [];

          while (this.explosionLength--) {
            this.coordinates.push([x, y]);
          }
        }

        update(callback) {
          this.coordinates.pop();
          this.coordinates.unshift([this.x, this.y]);

          this.speed *= this.friction;
          this.x += Math.cos(this.angle) * this.speed;
          this.y += Math.sin(this.angle) * this.speed + this.gravity;

          this.alpha -= this.decay;

          if (this.alpha <= this.decay) {
            callback();
          }
        }

        draw() {
          const lastIndex = this.coordinates.length - 1;
          this.ctx.beginPath();
          this.ctx.lineWidth = this.lineWidth;
          this.ctx.fillStyle = hsla(this.hue, this.brightness, this.alpha);
          this.ctx.moveTo(
            this.coordinates[lastIndex][0],
            this.coordinates[lastIndex][1]
          );
          this.ctx.lineTo(this.x, this.y);
          this.ctx.strokeStyle = hsla(
            this.hue,
            this.flickering ? randomFloat(0, this.brightness) : this.brightness,
            this.alpha
          );
          this.ctx.stroke();
        }
      }

      // Mouse class
      class Mouse {
        constructor(options, canvas) {
          this.options = options;
          this.canvas = canvas;
          this.active = false;
          this.x = 0;
          this.y = 0;

          this.pointerDown = this.pointerDown.bind(this);
          this.pointerUp = this.pointerUp.bind(this);
          this.pointerMove = this.pointerMove.bind(this);
        }

        get mouseOptions() {
          return this.options.mouse;
        }

        mount() {
          this.canvas.addEventListener("pointerdown", this.pointerDown);
          this.canvas.addEventListener("pointerup", this.pointerUp);
          this.canvas.addEventListener("pointermove", this.pointerMove);
        }

        unmount() {
          this.canvas.removeEventListener("pointerdown", this.pointerDown);
          this.canvas.removeEventListener("pointerup", this.pointerUp);
          this.canvas.removeEventListener("pointermove", this.pointerMove);
        }

        usePointer(event, active) {
          const { click, move } = this.mouseOptions;
          if (click || move) {
            const rect = this.canvas.getBoundingClientRect();
            this.x = event.clientX - rect.left;
            this.y = event.clientY - rect.top;
            this.active = active;
          }
        }

        pointerDown(event) {
          this.usePointer(event, this.mouseOptions.click);
        }

        pointerUp(event) {
          this.usePointer(event, false);
        }

        pointerMove(event) {
          this.usePointer(event, this.active);
        }
      }

      // Resize class
      class Resize {
        constructor(options, updateSize, container) {
          this.options = options;
          this.updateSize = updateSize;
          this.container = container;
          this.resizer = null;
        }

        mount() {
          if (!this.resizer) {
            const debouncedResize = debounce(() => this.updateSize(), 100);
            this.resizer = new ResizeObserver(debouncedResize);
          }
          if (this.options.autoresize) {
            this.resizer.observe(this.container);
          }
        }

        unmount() {
          if (this.resizer) {
            this.resizer.unobserve(this.container);
          }
        }
      }

      // RequestAnimationFrame class
      class RequestAnimationFrame {
        constructor(options, render) {
          this.options = options;
          this.render = render;
          this.tick = 0;
          this.rafId = 0;
          this.fps = 60;
          this.tolerance = 0.1;
          this.now = 0;
        }

        mount() {
          this.now = performance.now();
          const interval = 1000 / this.fps;
          const raf = (timestamp) => {
            this.rafId = requestAnimationFrame(raf);
            const delta = timestamp - this.now;
            if (delta >= interval - this.tolerance) {
              this.render();
              this.now = timestamp - (delta % interval);
              this.tick += (delta * (this.options.intensity * Math.PI)) / 1000;
            }
          };
          this.rafId = requestAnimationFrame(raf);
        }

        unmount() {
          cancelAnimationFrame(this.rafId);
        }
      }
    </script>
</body>
</html>